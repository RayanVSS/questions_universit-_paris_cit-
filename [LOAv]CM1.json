[
  {
    "question": "Quelle est la valeur de la constante `EXIT_SUCCESS` en C++ ?",
    "r√©ponse": "0",
    "explication": "`EXIT_SUCCESS` est d√©fini comme la constante enti√®re 0 (`EXIT_FAILURE` vaut 1).",
    "typing": true
  },
  {
    "question": "Parmi les syntaxes suivantes, laquelle est la syntaxe d'initialisation pr√©f√©r√©e en C++11 pour un entier `i`¬†?",
    "r√©ponse": "int i{4};",
    "explication": "En C++11, la forme avec liste d'initialisation (`{}`) est recommand√©e¬†: `int i{4};`.",
    "typing": false,
    "r√©ponse possible": [
      "int i(4);",
      "int i = 4;",
      "int i{4};",
      "int i={4};",
      "int i;"
    ]
  },
  {
    "question": "Apr√®s compilation manuelle avec `g++ -c -Wall -std=c++11 test.cpp`, quel fichier est produit¬†?",
    "r√©ponse": "test.o",
    "explication": "L'option `-c` demande uniquement la compilation sans √©dition des liens, g√©n√©rant un fichier objet `.o`.",
    "typing": true
  },
  {
    "question": "Quel est le r√¥le d'un gardien (`#ifndef ... #define ... #endif`) dans un fichier d'en-t√™te `.hpp`¬†?",
    "r√©ponse": "Emp√™cher les inclusions multiples du m√™me fichier d'en-t√™te",
    "explication": "Le gardien garantit que le contenu du `.hpp` n'est inclus qu'une seule fois lors de la pr√©compilation.",
    "typing": false,
    "r√©ponse possible": [
      "Optimiser le code g√©n√©r√©",
      "G√©rer les d√©pendances du Makefile",
      "Emp√™cher les inclusions multiples du m√™me fichier d'en-t√™te",
      "D√©finir des variables de configuration"
    ]
  },
  {
    "question": "Quelle commande Makefile g√©n√®re l'ex√©cutable `go` √† partir des fichiers objets `Point.o` et `Test.o`¬†?",
    "r√©ponse": "g++ -o go -Wall -std=c++11 Point.o Test.o",
    "explication": "On lie les fichiers objets avec `g++ -o <nom_ex√©cutable> <objets>` pour cr√©er l'ex√©cutable.",
    "typing": false,
    "r√©ponse possible": [
      "g++ -o go -Wall -std=c++11 Point.o Test.o",
      "g++ -o -Wall -std=c++11 Point.o Test.o -o go",
      "g++ -o go -Wall -std=c++11 Point Test"
    ]
  },
  {
    "question": "En C++, que fait l'instruction `using namespace std;` ?",
    "r√©ponse": "Elle rend accessibles sans pr√©fixe les entit√©s du namespace `std`",
    "explication": "Sans ce `using`, il faut √©crire `std::cout`, `std::string`, etc. Avec lui, on peut omettre `std::`.",
    "typing": false,
    "r√©ponse possible": [
      "Elle importe tout le contenu de l'espace de nom `std`",
      "Elle d√©finit un alias pour `std`",
      "Elle cr√©e un nouveau namespace `using`",
      "Elle rend accessibles sans pr√©fixe les entit√©s du namespace `std`"
    ]
  },
  {
    "question": "Quelle est la diff√©rence de comportement entre¬†:\n```cpp\nvector<int> v1 {4,100};\nvector<int> v2 (4,100);\n```",
    "r√©ponse": "v1 contient [4,100], v2 contient quatre fois 100",
    "explication": "`v1` utilise le constructeur `initializer_list` et a deux √©l√©ments¬†: 4 et 100. `v2` utilise le constructeur (n, val) et contient 4 √©l√©ments valant 100.",
    "typing": false,
    "r√©ponse possible": [
      "v1 contient quatre fois 100, v2 contient [4,100]",
      "v1 contient [4,100], v2 contient quatre fois 100",
      "Les deux contiennent [4,100]",
      "Les deux contiennent quatre fois 100"
    ]
  },
  {
    "question": "En C++, quel op√©rateur est surcharg√© pour envoyer des donn√©es vers `cout`¬†?",
    "r√©ponse": "<<",
    "explication": "L'op√©rateur `<<` est surcharg√© dans la librairie iostream pour formater et envoyer des donn√©es dans un flux de sortie.",
    "typing": true
  },
  {
    "question": "Les √©num√©rations (`enum`) en C++ peuvent-elles impl√©menter des interfaces (concepts)¬†?",
    "r√©ponse": "Faux",
    "explication": "Contrairement √† Java, les `enum` en C++ ne peuvent pas impl√©menter d'interfaces¬†; ils sont de simples types √©num√©r√©s.",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "Lors de la compilation, quelle phase pr√©c√®de l'√©dition des liens¬†?",
    "r√©ponse": "La compilation des fichiers sources en fichier √©xecutable",
    "explication": "D'abord chaque `.cpp` est compil√© en `.o`, puis l'√©diteur de liens assemble ces objets en ex√©cutable.",
    "typing": false,
    "r√©ponse possible": [
      "La pr√©compilation des gardiens",
      "La compilation des fichiers sources en fichier √©xecutable",
      "L'ex√©cution du programme",
      "Le nettoyage (`clean`)"
    ]
  },
  {
    "question": "Quel mot-cl√© en C++ sert √† d√©clarer qu'un param√®tre de fonction ne peut pas √™tre modifi√©¬†?",
    "r√©ponse": "const",
    "explication": "En pla√ßant `const` devant un param√®tre, on interdit toute modification de sa valeur √† l'int√©rieur de la fonction.",
    "typing": false,
    "r√©ponse possible": [
      "static",
      "volatile",
      "const",
      "mutable"
    ]
  },
  {
    "question": "Quel mot-cl√© permet de d√©duire le type d'une variable √† partir de son initialisateur en C++11 ?",
    "r√©ponse": "auto",
    "explication": "Le mot-cl√© `auto` indique au compilateur de d√©terminer automatiquement le type de la variable.",
    "typing": true
  },
  {
    "question": "Quelle valeur renvoie `std::vector<int>().size()` ?",
    "r√©ponse": "0",
    "explication": "Un vecteur vide a une taille (`size()`) √©gale √† 0.",
    "typing": true
  },
  {
    "question": "Que fait la m√©thode `push_back` sur un `std::vector` ?",
    "r√©ponse": "Ajoute un √©l√©ment √† la fin du vecteur",
    "explication": "`push_back(val)` ins√®re la valeur `val` en tant que nouvel √©l√©ment √† la fin du vecteur.",
    "typing": false,
    "r√©ponse possible": [
      "Supprime le dernier √©l√©ment",
      "Ins√®re un √©l√©ment au d√©but",
      "Ajoute un √©l√©ment √† la fin du vecteur",
      "Trie le vecteur"
    ]
  },
  {
    "question": "Combien y a‚Äët‚Äëil d‚Äô√©l√©ments apr√®s :\n```cpp\nstd::array<int,5> a = {1,2,3,4,5};\n```",
    "r√©ponse": "5",
    "explication": "`std::array<int,5>` est un tableau fixe de 5 √©l√©ments.",
    "typing": true
  },
  {
    "question": "Quel est l‚Äôeffet de `std::move` sur un objet ?",
    "r√©ponse": "Indique que l‚Äôobjet peut √™tre d√©plac√© plut√¥t que copi√©",
    "explication": "`std::move(obj)` convertit `obj` en rvalue, autorisant le transfert de ressources sans copie.",
    "typing": false,
    "r√©ponse possible": [
      "Copie l‚Äôobjet",
      "Supprime l‚Äôobjet",
      "Indique que l‚Äôobjet peut √™tre d√©plac√© plut√¥t que copi√©",
      "Convertit l‚Äôobjet en pointeur"
    ]
  },
  {
    "question": "Quel est le type de retour de la fonction `main` en C++ ?",
    "r√©ponse": "int",
    "explication": "La fonction `main` doit retourner un entier, g√©n√©ralement 0 pour indiquer un succ√®s.",
    "typing": true
  },
  {
    "question": "Quelle est la diff√©rence entre `std::vector` et `std::list` en C++ ?",
    "r√©ponse": "`std::vector` est un tableau dynamique, `std::list` est une liste cha√Æn√©e",
    "explication": "`std::vector` offre un acc√®s rapide aux √©l√©ments par index, tandis que `std::list` permet des insertions/suppressions efficaces.",
    "typing": false,
    "r√©ponse possible": [
      "`std::vector` est un tableau dynamique, `std::list` est une liste cha√Æn√©e",
      "`std::vector` est une liste cha√Æn√©e, `std::list` est un tableau dynamique",
      "`std::vector` n'existe pas en C++",
      "`std::list` n'existe pas en C++"
    ]
  },
  {
    "question": "Quel type C++ g√®re automatiquement la lib√©ration de m√©moire dynamique ?",
    "r√©ponse": "std::unique_ptr",
    "explication": "`std::unique_ptr<T>` supprime automatiquement l‚Äôobjet point√© lorsque le pointeur sort de son scope.",
    "typing": false,
    "r√©ponse possible": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "question": "le code compile t-il ? \n```cpp\n #include <iostream>\nint main() {\ncout << \"Bonjour tout le monde\" << endl;\nreturn EXIT_SUCCESS;\n}```",
    "r√©ponse": "Faux",
    "typing": false,
    "explication": "Le code ne compile pas car `cout` et `endl` doivent √™tre pr√©fix√©s par `std::` ou le namespace `std` doit √™tre utilis√©.\n```cpp\n #include <iostream>\n**using namespace std;**\nint main() {\ncout << \"Bonjour tout le monde\" << endl;\nreturn EXIT_SUCCESS;\n}``` \n ou \n ```cpp\n #include <iostream>\nint main() {\n**std::**cout << \"Bonjour tout le monde\" << **std::**endl;\nreturn EXIT_SUCCESS;\n}``` ",
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
      {
    "question": "qu'affiche la ‚Äãligne üü¢‚Äã \n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n bool b1=true, b2=false;\n cout << b1 << b2 << endl; üü¢\n cout << boolalpha;\n cout << b1 << b2 << endl; \n}```",
    "r√©ponse": "10",
    "explication": "La ligne üü¢ affiche les valeurs bool√©ennes `true` et `false` sous forme d'entiers, donc `1` pour `true` et `0` pour `false`.",
    "typing": true
  },
  {
    "question": "qu'affiche la ‚Äãligne üü£ \n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n bool b1=true, b2=false;\n cout << b1 << b2 << endl; \n cout << boolalpha;\n cout << b1 << b2 << endl; üü£\n}```",
    "r√©ponse": "truefalse",
    "explication": "La ligne üü£ utilise `boolalpha`, ce qui affiche les valeurs bool√©ennes sous forme de mots (`true` et `false`).",
    "typing": true
  },
{
    "question": "qu'affiche la ligne üî∑```cpp\n#include <iostream>\nusing namespace std;\n\nvoid afficher(int n) {\n cout << \"int:\" << n << endl;\n}\n\nvoid afficher(float f) {\n cout << \"float:\" << f << endl;\n}\n\nint main() {\n int i=13; float f=3.14159;\n afficher(i); \n afficher(f); üî∑‚Äã\n return EXIT_SUCCESS;\n}```",
    "r√©ponse": "float:3.14159",
    "explication": "La ligne üî∑ appelle la fonction `afficher` avec un argument de type `float`, donc la version de la fonction qui prend un `float` est appel√©e, affichant `3.14159`.",
    "typing": false,
    "r√©ponse possible": [
      "ne compile pas",
      "float:3.14159",
      "int:13",
      "int:3.14159"
    ]
  },
  {
    "question": "La s√©paration hpp/cpp est-elle toujours propre ?",
    "r√©ponse": "Faux",
    "explication": "Malheureusement vous pouvez faire ce que vous voulez : √©crire vos fichiers avec une autre extension, mettre une partie de code dans la d√©claration, d√©finir une classe dans le cpp etc ... cela peut conduire √† des pbs : un code d√©fini dans le hpp sera recopi√© autant de fois qu'il y a un include la seconde red√©finition sera interdite et consid√©r√©e comme une erreur (et si vous d√©clarez une classe dans un cpp n‚Äôallez pas imaginer faire un include de ce .cpp ensuite ... bref... confusions ... )",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "En c++, lorsque vous d√©finissez une fonction √† plusieurs arguments, sa d√©claration (pr√©alable ou dans le hpp) peut contenir des **\"valeurs par d√©faut\"**",
    "r√©ponse": "Vrai",
    "explication": "En c++, lorsque vous d√©finissez une fonction √† plusieurs arguments : ```cpp\nvoid f (int a, char b, string c) {\nstring res{c+' '};\nif (a<0) a=-a;\nfor (int i=0;i < a;i++) res+=b;\ncout << res << endl;\n}```\ndestin√©e √† √™tre appel√©e sous la forme : `f(5,'A',\"coucou\");`\nqui produit ici : `coucou AAAAA` \nsa d√©claration (pr√©alable ou dans le hpp) peut contenir des **\"valeurs par d√©faut\"**\ncela permet de faire appel √† f sans avoir √† tout sp√©cifier.\nAinsi :\n  f() produira : toto X\n  f(5) produira : toto XXXXX \n",
    "typing": false,
    "r√©ponse possible": [
      "Vrai",
      "Faux"
    ]
  },
  {
    "question": "que produit ce code :```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid f (int a =1, char b='X', string c=\"toto\");\n\nvoid f (int a, char b, string c) {\n    string res{c+' '};\n    if (a<0) a=-a;\n    for (int i=0;i < a;i++) res+=b;\n    cout << res << endl;\n}\n\nint main() {\n    f('A');\n    return 0;\n}```\n",
    "r√©ponse": "toto XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX (65*'X')",
    "explication": "En c++, lorsque vous d√©finissez une fonction √† plusieurs arguments : ```cpp\nvoid f (int a, char b, string c) {\nstring res{c+' '};\nif (a<0) a=-a;\nfor (int i=0;i < a;i++) res+=b;\ncout << res << endl;\n}```\ndestin√©e √† √™tre appel√©e sous la forme : `f(5,'A',\"coucou\");`\nqui produit ici : `coucou AAAAA` \nsa d√©claration (pr√©alable ou dans le hpp) peut contenir des **\"valeurs par d√©faut\"**\ncela permet de faire appel √† f sans avoir √† tout sp√©cifier.\nAinsi :\n  f() produira : toto X\n  f(5) produira : toto XXXXX \n  f('A') produira toto XXXX ...65fois... X (car le code ascii de 'A' est 65)",
    "typing": false,
    "r√©ponse possible": [
      "toto A",
      "A X",
      "toto XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX (65*'X')",
      "message d'erreur"
    ]
  }
]
